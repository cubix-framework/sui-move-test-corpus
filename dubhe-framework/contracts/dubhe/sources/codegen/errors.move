  // Copyright (c) Obelisk Labs, Inc.
  // SPDX-License-Identifier: Apache-2.0
  #[allow(unused_use)]
  
  /* Autogenerated file. Do not edit manually. */
  
  module dubhe::dubhe_errors {

  #[error]

  const ASSET_NOT_FOUND: vector<u8> = b"Asset not found";

  public fun asset_not_found_error(condition: bool) {
    assert!(condition, ASSET_NOT_FOUND)
  }

  #[error]

  const ASSET_ALREADY_FROZEN: vector<u8> = b"Asset already frozen";

  public fun asset_already_frozen_error(condition: bool) {
    assert!(condition, ASSET_ALREADY_FROZEN)
  }

  #[error]

  const ASSET_NOT_LIQUID: vector<u8> = b"Asset not liquid";

  public fun asset_not_liquid_error(condition: bool) {
    assert!(condition, ASSET_NOT_LIQUID)
  }

  #[error]

  const ASSET_NOT_FROZEN: vector<u8> = b"Asset not frozen";

  public fun asset_not_frozen_error(condition: bool) {
    assert!(condition, ASSET_NOT_FROZEN)
  }

  #[error]

  const INVALID_SENDER: vector<u8> = b"Invalid sender";

  public fun invalid_sender_error(condition: bool) {
    assert!(condition, INVALID_SENDER)
  }

  #[error]

  const INVALID_RECEIVER: vector<u8> = b"Invalid receiver";

  public fun invalid_receiver_error(condition: bool) {
    assert!(condition, INVALID_RECEIVER)
  }

  #[error]

  const ACCOUNT_NOT_FOUND: vector<u8> = b"Account not found";

  public fun account_not_found_error(condition: bool) {
    assert!(condition, ACCOUNT_NOT_FOUND)
  }

  #[error]

  const ACCOUNT_BLOCKED: vector<u8> = b"Account is blocked";

  public fun account_blocked_error(condition: bool) {
    assert!(condition, ACCOUNT_BLOCKED)
  }

  #[error]

  const ACCOUNT_FROZEN: vector<u8> = b"Account is frozen";

  public fun account_frozen_error(condition: bool) {
    assert!(condition, ACCOUNT_FROZEN)
  }

  #[error]

  const BALANCE_TOO_LOW: vector<u8> = b"Balance too low";

  public fun balance_too_low_error(condition: bool) {
    assert!(condition, BALANCE_TOO_LOW)
  }

  #[error]

  const OVERFLOWS: vector<u8> = b"Operation overflows";

  public fun overflows_error(condition: bool) {
    assert!(condition, OVERFLOWS)
  }

  #[error]

  const NO_PERMISSION: vector<u8> = b"No permission";

  public fun no_permission_error(condition: bool) {
    assert!(condition, NO_PERMISSION)
  }

  #[error]

  const NOT_MINTABLE: vector<u8> = b"Asset is not mintable";

  public fun not_mintable_error(condition: bool) {
    assert!(condition, NOT_MINTABLE)
  }

  #[error]

  const NOT_BURNABLE: vector<u8> = b"Asset is not burnable";

  public fun not_burnable_error(condition: bool) {
    assert!(condition, NOT_BURNABLE)
  }

  #[error]

  const NOT_FREEZABLE: vector<u8> = b"Asset is not freezable";

  public fun not_freezable_error(condition: bool) {
    assert!(condition, NOT_FREEZABLE)
  }

  #[error]

  const POOL_ALREADY_EXISTS: vector<u8> = b"Pool already exists";

  public fun pool_already_exists_error(condition: bool) {
    assert!(condition, POOL_ALREADY_EXISTS)
  }

  #[error]

  const BELOW_MIN_AMOUNT: vector<u8> = b"Amount is below minimum";

  public fun below_min_amount_error(condition: bool) {
    assert!(condition, BELOW_MIN_AMOUNT)
  }

  #[error]

  const BELOW_MIN_LIQUIDITY: vector<u8> = b"Amount is below Liquidity";

  public fun below_min_liquidity_error(condition: bool) {
    assert!(condition, BELOW_MIN_LIQUIDITY)
  }

  #[error]

  const POOL_NOT_FOUND: vector<u8> = b"Pool not found";

  public fun pool_not_found_error(condition: bool) {
    assert!(condition, POOL_NOT_FOUND)
  }

  #[error]

  const MORE_THAN_MAX_SWAP_PATH_LEN: vector<u8> = b"More than Max";

  public fun more_than_max_swap_path_len_error(condition: bool) {
    assert!(condition, MORE_THAN_MAX_SWAP_PATH_LEN)
  }

  #[error]

  const SWAP_PATH_TOO_SMALL: vector<u8> = b"Swap path too small";

  public fun swap_path_too_small_error(condition: bool) {
    assert!(condition, SWAP_PATH_TOO_SMALL)
  }

  #[error]

  const RESERVES_CANNOT_BE_ZERO: vector<u8> = b"Reserve cannot be 0";

  public fun reserves_cannot_be_zero_error(condition: bool) {
    assert!(condition, RESERVES_CANNOT_BE_ZERO)
  }

  #[error]

  const AMOUNT_CANNOT_BE_ZERO: vector<u8> = b"Amount cannot be 0";

  public fun amount_cannot_be_zero_error(condition: bool) {
    assert!(condition, AMOUNT_CANNOT_BE_ZERO)
  }

  #[error]

  const LESS_THAN_AMOUNT_OUT_MIN: vector<u8> = b"Less than expected";

  public fun less_than_amount_out_min_error(condition: bool) {
    assert!(condition, LESS_THAN_AMOUNT_OUT_MIN)
  }

  #[error]

  const MORE_THAN_AMOUNT_IN_MAX: vector<u8> = b"More than expected";

  public fun more_than_amount_in_max_error(condition: bool) {
    assert!(condition, MORE_THAN_AMOUNT_IN_MAX)
  }

  #[error]

  const CHAIN_NOT_SUPPORTED: vector<u8> = b"Chain not supported";

  public fun chain_not_supported_error(condition: bool) {
    assert!(condition, CHAIN_NOT_SUPPORTED)
  }

  #[error]

  const BRIDGE_NOT_OPENED: vector<u8> = b"Bridge is not opened";

  public fun bridge_not_opened_error(condition: bool) {
    assert!(condition, BRIDGE_NOT_OPENED)
  }

  #[error]

  const BELOW_MIN_BRIDGE_AMOUNT: vector<u8> = b"Amount is below minimum";

  public fun below_min_bridge_amount_error(condition: bool) {
    assert!(condition, BELOW_MIN_BRIDGE_AMOUNT)
  }

  #[error]

  const NOT_DAPP_ADMIN: vector<u8> = b"Not dapp admin";

  public fun not_dapp_admin_error(condition: bool) {
    assert!(condition, NOT_DAPP_ADMIN)
  }

  #[error]

  const NOT_DAPP_LATEST_VERSION: vector<u8> = b"Not dapp latest version";

  public fun not_dapp_latest_version_error(condition: bool) {
    assert!(condition, NOT_DAPP_LATEST_VERSION)
  }

  #[error]

  const NOT_DAPP_PAUSABLE: vector<u8> = b"Dapp is not pausable";

  public fun not_dapp_pausable_error(condition: bool) {
    assert!(condition, NOT_DAPP_PAUSABLE)
  }

  #[error]

  const DAPP_ALREADY_EXISTS: vector<u8> = b"Dapp already exists";

  public fun dapp_already_exists_error(condition: bool) {
    assert!(condition, DAPP_ALREADY_EXISTS)
  }
}
