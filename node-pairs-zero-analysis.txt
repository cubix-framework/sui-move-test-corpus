PAIR: AbortExpression -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: AbortExpression -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: AnnotationExpression -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: AnnotationExpression -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: ArgList -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: ArgList -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: AssignExpression -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: AssignExpression -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression1 -> HiddenExpressionAssignExpression
IMPOSSIBLE: The assign operator `=` has precedence 1, which is lower than the implies operator `==>` with precedence 2. In `a ==> x = 5`, tree-sitter's precedence resolution reduces `a ==> x` first (prec 2 beats prec 1), preventing `x = 5` from forming as a child assign_expression. And `(a ==> x) = 5` fails because a binary_expression cannot be the LHS of assign (which requires `_unary_expression`). Parentheses would create an expression_list node, not a raw assign_expression.

PAIR: BinaryExpression1 -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression1 -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression10 -> HiddenExpressionAssignExpression
IMPOSSIBLE: The assign operator `=` has precedence 1, which is lower than the range operator `..` with precedence 6. In `a .. x = 5`, tree-sitter's precedence resolution reduces `a .. x` first (prec 6 beats prec 1), preventing `x = 5` from forming as a child assign_expression. And `(a .. x) = 5` fails because a binary_expression cannot be the LHS of assign (which requires `_unary_expression`). Parentheses would create an expression_list node, not a raw assign_expression.

PAIR: BinaryExpression10 -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression10 -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression11 -> HiddenExpressionAssignExpression
IMPOSSIBLE: AssignExpression has prec.left(1), which is lower than bitor's prec 7. On the RHS, the `|` operator at prec 7 steals the assign's LHS (a `_unary_expression` like `x`), producing `(a | x) = y`. But `a | x` is a binary expression, not a `_unary_expression`, so `= y` cannot form a valid assign_expression. On the LHS, assign at prec 1 loses to bitor at prec 7, so the bitor operator steals from within the assign. There is no way to construct an assign_expression as a direct child of a bitor binary expression without parentheses (which would create an ExpressionList node instead).

PAIR: BinaryExpression11 -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression11 -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression12 -> HiddenExpressionAssignExpression
IMPOSSIBLE: AssignExpression has prec.left(1), which is lower than xor's prec 8. On the RHS, the `^` operator at prec 8 steals the assign's LHS (a `_unary_expression` like `x`), producing `(a ^ x) = y`. But `a ^ x` is a binary expression, not a `_unary_expression`, so `= y` cannot form a valid assign_expression. On the LHS, assign at prec 1 loses to xor at prec 8. There is no way to construct an assign_expression as a direct child of a xor binary expression.

PAIR: BinaryExpression12 -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression12 -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression13 -> HiddenExpressionAssignExpression
IMPOSSIBLE: The assign_expression has precedence 1 (prec.left(1)), which is lower than bitand's precedence 9. When parsing `a & x = b`, the parser resolves the shift-reduce conflict by reducing `a & x` as a binary_expression (prec 9 > prec 1), making `x` part of the bitand's RHS rather than the assign's LHS. The resulting `(a & x) = b` then fails because binary_expression is not _unary_expression (required for assign's LHS). There is no syntactic arrangement that places assign_expression as a direct child of BinaryExpression13.

PAIR: BinaryExpression13 -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression13 -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression14 -> HiddenExpressionAssignExpression
IMPOSSIBLE: The assign_expression has precedence 1 (prec.left(1)), which is lower than shl's precedence 10. When parsing `a << x = b`, the parser resolves the shift-reduce conflict by reducing `a << x` as a binary_expression (prec 10 > prec 1), making `x` part of shl's RHS rather than the assign's LHS. The resulting `(a << x) = b` then fails because binary_expression is not _unary_expression (required for assign's LHS). There is no syntactic arrangement that places assign_expression as a direct child of BinaryExpression14.

PAIR: BinaryExpression14 -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression14 -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression15 -> HiddenExpressionAssignExpression
IMPOSSIBLE: AssignExpression has precedence 1, while >> has precedence 10. When parsing `a >> x = y`, tree-sitter's precedence resolution makes `x` bind to `>>` (prec 10 > 1), producing `(a >> x) = y`. But `(a >> x)` is a binary_expression, not a _unary_expression, so it cannot be the LHS of assign_expression (which requires _unary_expression as LHS). There is no way to make assign_expression appear as a direct child of any binary expression without parentheses, and parentheses create an expression_list node instead.

PAIR: BinaryExpression15 -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression15 -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression16 -> HiddenExpressionAssignExpression
IMPOSSIBLE: AssignExpression has precedence 1, while + has precedence 11. When parsing `a + x = y`, tree-sitter's precedence resolution makes `x` bind to `+` (prec 11 > 1), producing `(a + x) = y`. But `(a + x)` is a binary_expression, not a _unary_expression, so it cannot be the LHS of assign_expression. There is no way to make assign_expression appear as a direct child of any binary expression without parentheses, and parentheses create an expression_list node instead.

PAIR: BinaryExpression16 -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression16 -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression17 -> HiddenExpressionAssignExpression
IMPOSSIBLE: AssignExpression has precedence 1, while - has precedence 11. When parsing `a - x = y`, tree-sitter's precedence resolution makes `x` bind to `-` (prec 11 > 1), producing `(a - x) = y`. But `(a - x)` is a binary_expression, not a _unary_expression, so it cannot be the LHS of assign_expression. There is no way to make assign_expression appear as a direct child of any binary expression without parentheses, and parentheses create an expression_list node instead.

PAIR: BinaryExpression17 -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression17 -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression18 -> HiddenExpressionAssignExpression
IMPOSSIBLE: The `assign_expression` has `prec.left(1)`, meaning `=` binds at precedence 1. The `*` operator has precedence 12. For `a * x = 5`, the `*` operator (prec 12 > prec 1) steals the operand `x` from `=`, producing `(a * x) = 5`. But `a * x` is a binary_expression, not a `_unary_expression` (which is required as the lhs of `assign_expression`), so this parse fails. There is no way to make `assign_expression` appear as a direct child of `*` because any valid lhs of `=` (a `_unary_expression`) would be captured by `*` first due to higher precedence. Parentheses would create an `expression_list` node, not an `assign_expression`.

PAIR: BinaryExpression18 -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression18 -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression19 -> HiddenExpressionAssignExpression
IMPOSSIBLE: The `assign_expression` has `prec.left(1)`, and `/` has precedence 12. For `a / x = 5`, the `/` operator (prec 12 > prec 1) captures `x` as its rhs before `=` can claim it as its lhs. The resulting `(a / x) = 5` fails because `a / x` (a binary_expression) is not a valid `_unary_expression` for the lhs of `=`. There is no way to make an assign_expression a direct child of `/` without parentheses (which would create an `expression_list` instead).

PAIR: BinaryExpression19 -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression19 -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression2 -> HiddenExpressionAssignExpression
IMPOSSIBLE: The `assign_expression` has `prec.left(1)`, and `||` has precedence 3. For `a || x = 5`, the `||` operator (prec 3 > prec 1) captures `x` as its rhs before `=` can claim it as its lhs. The resulting `(a || x) = 5` fails because `a || x` (a binary_expression) is not a valid `_unary_expression` for the lhs of `=`. There is no way to make an assign_expression a direct child of `||` without parentheses (which would create an `expression_list` instead).

PAIR: BinaryExpression2 -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression2 -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression20 -> HiddenExpressionAssignExpression
IMPOSSIBLE: The assign operator `=` has precedence 1, which is lower than `%` at precedence 12. When parsing `a % x = y`, tree-sitter encounters a shift/reduce conflict at `=`: reduce `a % x` to binary_expression (prec 12) or shift `=` for assign_expression (prec 1). Since 12 > 1, reduce wins, producing `(a % x) = y`. But `(a % x)` is a binary_expression, not a `_unary_expression`, so the assign_expression parse fails. The alternative parse `a % (x = y)` is never reached due to precedence resolution. Parenthesizing would create an ExpressionList node, not a direct assign child.

PAIR: BinaryExpression20 -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression20 -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression3 -> HiddenExpressionAssignExpression
IMPOSSIBLE: The assign operator `=` has precedence 1, which is lower than `&&` at precedence 4. When parsing `a && x = y`, tree-sitter encounters a shift/reduce conflict at `=`: reduce `a && x` to binary_expression (prec 4) or shift `=` for assign_expression (prec 1). Since 4 > 1, reduce wins, producing `(a && x) = y`. But `(a && x)` is a binary_expression, not a `_unary_expression`, so the assign_expression parse fails. The alternative parse `a && (x = y)` is never reached due to precedence resolution. Parenthesizing would create an ExpressionList node, not a direct assign child.

PAIR: BinaryExpression3 -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression3 -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression4 -> HiddenExpressionAssignExpression
IMPOSSIBLE: assign_expression has prec.left(1), which is lower than == (prec 5). In `a == x = y`, the higher-precedence == binds `x` first as its rhs, producing `(a == x) = y` rather than `a == (x = y)`. There is no token sequence that places an assign_expression as a direct child of == without parentheses (which would create an ExpressionList node instead).

PAIR: BinaryExpression4 -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression4 -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression5 -> HiddenExpressionAssignExpression
IMPOSSIBLE: assign_expression has prec.left(1), which is lower than != (prec 5). In `a != x = y`, the higher-precedence != binds `x` first as its rhs, producing `(a != x) = y` rather than `a != (x = y)`. There is no token sequence that places an assign_expression as a direct child of != without parentheses (which would create an ExpressionList node instead).

PAIR: BinaryExpression5 -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression5 -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression6 -> HiddenExpressionAssignExpression
IMPOSSIBLE: assign_expression has prec.left(1), which is lower than < (prec 5). In `a < x = y`, the higher-precedence < binds `x` first as its rhs, producing `(a < x) = y` rather than `a < (x = y)`. There is no token sequence that places an assign_expression as a direct child of < without parentheses (which would create an ExpressionList node instead).

PAIR: BinaryExpression6 -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression6 -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression7 -> HiddenExpressionAssignExpression
IMPOSSIBLE: AssignExpression has precedence 1, which is lower than BinaryExpression7's precedence 5. In `a > x = 5`, the `>` at prec 5 binds tighter than `=` at prec 1, so the parser groups it as `(a > x) = 5`, making the binary expression a child of the assign expression, not the other way around. Additionally, assign_expression requires its lhs to be `_unary_expression`, and `a > x` is a binary expression, so this parse also fails. There is no way to make an assign expression a direct child of a `>` binary expression without parentheses (which would create an ExpressionList node instead).

PAIR: BinaryExpression7 -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression7 -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression8 -> HiddenExpressionAssignExpression
IMPOSSIBLE: AssignExpression has precedence 1, which is lower than BinaryExpression8's precedence 5. In `a <= x = 5`, the `<=` at prec 5 binds tighter than `=` at prec 1, so the parser groups it as `(a <= x) = 5`, making the binary expression a child of the assign expression, not the other way around. Additionally, assign_expression requires its lhs to be `_unary_expression`, and `a <= x` is a binary expression, so this parse also fails. There is no way to make an assign expression a direct child of a `<=` binary expression without parentheses (which would create an ExpressionList node instead).

PAIR: BinaryExpression8 -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression8 -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression9 -> HiddenExpressionAssignExpression
IMPOSSIBLE: AssignExpression has precedence 1, which is lower than BinaryExpression9 (>=, precedence 5). In `x >= a = 5`, the >= operator at prec 5 beats assign at prec 1, so tree-sitter reduces `x >= a` first, making the assign the parent of the binary expression, not the other way around. On the LHS, `a = 5 >= x` similarly parses as `a = (5 >= x)` because >= shifts at prec 5 > assign's prec 1.

PAIR: BinaryExpression9 -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BinaryExpression9 -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: Block -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: Block -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BlockItemInternal0Expression -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BlockItemInternal0Expression -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BorrowExpression -> HiddenExpressionBinaryExpression
IMPOSSIBLE: BorrowExpression has precedence 13 (unary), which is higher than all binary operators (max precedence 12 for *, /, %). For any `&expr op expr2`, the borrow reduces before the binary operator can form, e.g. `&a + b` parses as `(&a) + b`. The only way to get a binary expression inside a borrow is with parentheses, which creates an ExpressionList node, not a direct BinaryExpression child.

PAIR: BorrowExpression -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BorrowExpression -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BreakExpression -> HiddenExpressionAssignExpression
IMPOSSIBLE: break_expression gets precedence 10 via _unary_expression. assign_expression has prec.left(1). When parsing `break x = 5`, after `break x` the parser sees `=`. The reduce (prec 10) beats the shift for assign (prec 1), so `x` reduces as break's child first, producing `(break x) = 5` â€” an assign with break as LHS, not break with assign as child. There is no way to get assign_expression as break's direct child without parentheses (which would create expression_list instead).

PAIR: BreakExpression -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: BreakExpression -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: CastExpression -> HiddenExpressionAbortExpression
IMPOSSIBLE: cast_expression is prec.left(16, expr as type). For abort_expression to be the LHS, we'd need `abort x as T`. But abort_expression takes _expression as its child, and within that child, `x as T` is a cast_expression at prec 16. Since cast has high precedence, the child _expression absorbs `as T`, producing abort_expression(abort, cast_expression(x, as, T)). There is no way to make abort the LHS of cast without parentheses (which create expression_list).

PAIR: CastExpression -> HiddenExpressionAssignExpression
IMPOSSIBLE: assign_expression has prec.left(1), and its LHS is _unary_expression (not _expression). For assign to be cast's LHS, we'd need `(x = 5) as T`, but assign_expression cannot appear as _unary_expression directly. Even `x = 5 as T` would parse as `x = (5 as T)` since cast (prec 16) binds tighter than assign (prec 1). There is no way to get assign_expression as cast's direct child expression.

PAIR: CastExpression -> HiddenExpressionBinaryExpression
IMPOSSIBLE: All binary operators have precedence 2-12, which is lower than cast's prec.left(16). For `a + b as T`, the cast binds tighter: `a + (b as T)`, making binary_expression the parent of cast, not the child. To get binary as cast's child, you'd need `(a + b) as T`, but parentheses create expression_list, not binary_expression.

PAIR: CastExpression -> HiddenExpressionIdentifiedExpression
IMPOSSIBLE: identified_expression is `block_identifier _expression` (e.g., `'label: expr`). It ends with _expression, which would absorb `as T` (cast at prec 16). So `'label: x as T` parses as `'label: (x as T)`, not `('label: x) as T`. There is no way to make identified_expression the LHS of cast.

PAIR: CastExpression -> HiddenExpressionIfExpression
IMPOSSIBLE: if_expression has prec.right(0) and ends with _expression (either the then-branch or else-branch). The trailing _expression absorbs `as T` (cast at prec 16 > if's prec 0). So `if (c) x as T` parses as `if (c) (x as T)`, and `if (c) x else y as T` parses as `if (c) x else (y as T)`. Even with block bodies like `if (c) { x } else { y } as T`, the else-branch _expression absorbs `as T` since cast (prec 16) beats the block's reduce.

PAIR: CastExpression -> HiddenExpressionLambdaExpression
IMPOSSIBLE: lambda_expression ends with _expression (the body), which would absorb `as T`. So `|x| expr as T` parses as `|x| (expr as T)`, not `(|x| expr) as T`. Lambda cannot be the LHS of cast.

PAIR: CastExpression -> HiddenExpressionLoopExpression
IMPOSSIBLE: loop_expression is `loop _expression`, ending with _expression which absorbs `as T`. So `loop x as T` parses as `loop (x as T)`, not `(loop x) as T`. Even `loop { ... } as T` has the block absorbing `as T` since cast at prec 16 > block's reduce prec.

PAIR: CastExpression -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: CastExpression -> HiddenExpressionQuantifierExpression
IMPOSSIBLE: quantifier_expression has prec.right(0) and ends with _expression (the body after `:`). The trailing _expression absorbs `as T` (cast at prec 16 > quantifier's prec 0). So `forall x: u64: expr as T` parses as `forall x: u64: (expr as T)`, not `(forall ...) as T`.

PAIR: CastExpression -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: CastExpression -> HiddenExpressionWhileExpression
IMPOSSIBLE: while_expression is `while (cond) body` where body is _expression. The body _expression absorbs `as T` (cast at prec 16). So `while (c) x as T` parses as `while (c) (x as T)`, not `(while (c) x) as T`. Even with block body `while (c) { ... } as T`, the body _expression absorbs `as T`.

PAIR: Constant -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: Constant -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: DereferenceExpression -> HiddenExpressionBinaryExpression
IMPOSSIBLE: Dereference expression has PREC_RIGHT(13), which is higher than all binary operators (max precedence 12 for *, /, %). In a shift-reduce conflict between completing the dereference and shifting a binary operator, the dereference always reduces first. For example, `*a + b` parses as `(*a) + b`, not `*(a + b)`. There is no way to make a binary expression the direct child of a dereference expression without parentheses, and parentheses would create an ExpressionList node instead.

PAIR: DereferenceExpression -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: DereferenceExpression -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: ExpField -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: ExpField -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: ExpressionList -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: ExpressionList -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: HiddenExpressionMatchExpression -> MatchExpression
IMPOSSIBLE: HiddenExpressionMatchExpression is never generated by tree-sitter as a direct child. The grammar's [$._expression, $._expression_term] conflict always routes match_expression through HiddenExpressionTermMatchExpression (via _expression_term path), so HiddenExpressionMatchExpression never appears. The pair HiddenExpressionMatchExpression -> MatchExpression can only be covered if HiddenExpressionMatchExpression itself appears, which it doesn't.

PAIR: HiddenExpressionVectorExpression -> VectorExpression
IMPOSSIBLE: HiddenExpressionVectorExpression is never generated by tree-sitter as a direct child. The grammar's [$._expression, $._expression_term] conflict always routes vector_expression through HiddenExpressionTermVectorExpression (via _expression_term path), so HiddenExpressionVectorExpression never appears. The pair HiddenExpressionVectorExpression -> VectorExpression can only be covered if HiddenExpressionVectorExpression itself appears, which it doesn't.

PAIR: HiddenSpecAbortIf -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: HiddenSpecAbortIf -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: HiddenSpecAbortWithOrModifies -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: HiddenSpecAbortWithOrModifies -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: HiddenSpecCondition -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: HiddenSpecCondition -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: HiddenUnaryExpressionInternal0ExpressionTerm -> HiddenExpressionTermIfExpression
IMPOSSIBLE: In _expression contexts, the Cubix parser matches if_expression as HiddenExpressionIfExpression before trying HiddenExpressionUnaryExpression, so the _unary_expression -> _expression_term path is never taken. The only context requiring _unary_expression specifically is the LHS of assign_expression, but tree-sitter's precedence resolution (assign at prec.left(1) vs if at prec.right(0)) always causes the = token to be absorbed into the if's branch rather than making the if the LHS of the assignment. Therefore, if_expression can never appear through the _unary_expression -> _expression_term path.

PAIR: IdentifiedExpression -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: IdentifiedExpression -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: IfExpression -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: IfExpression -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: IndexExpression -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: IndexExpression -> HiddenExpressionTermDotExpression
IMPOSSIBLE: Tree-sitter parses `v.data[0]` right-associatively as `dot(v, index(data, 0))` â€” i.e., `DotExpression -> HiddenExpressionTermIndexExpression`, not `IndexExpression -> HiddenExpressionTermDotExpression`. Since both index_expression and dot_expression have `$._expression_term` on their left side, wrapping a DotExpression in parens creates an ExpressionList (yielding `IndexExpression -> HiddenExpressionTermExpressionList`). There is no syntactic form that places a raw DotExpression as the LHS of an IndexExpression.

PAIR: IndexExpression -> HiddenExpressionTermIfExpression
IMPOSSIBLE: Tree-sitter parses `if (b) { v1 } else { v2 }[0]` by attaching the `[0]` subscript to the final else-block `{ v2 }`, yielding `IndexExpression -> HiddenExpressionTermBlock`, not `IndexExpression -> HiddenExpressionTermIfExpression`. Wrapping the if in parens creates ExpressionList, not a TermIfExpression. There is no syntactic form that places an IfExpression as the direct LHS of an IndexExpression.

PAIR: IndexExpression -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: LambdaBindingBind -> HiddenBindAtBind
IMPOSSIBLE: In the current parser, pLambdaBinding3 (matching HiddenBind followed by optional ': type') is tried before pLambdaBindingBind (matching just HiddenBind). Since pLambdaBinding3 uses pMaybe for the optional type annotation, it succeeds even for untyped lambda bindings (the pMaybe returns Nothing). Therefore pLambdaBinding3 always wins and pLambdaBindingBind is never reached. All lambda bindings (typed and untyped) go through LambdaBinding3.

PAIR: LambdaBindingBind -> HiddenBindBindInternal0
IMPOSSIBLE: See LambdaBindingBind -> HiddenBindAtBind. pLambdaBinding3 always wins over pLambdaBindingBind due to parser ordering and partial consumption.

PAIR: LambdaBindingBind -> HiddenBindBindUnpack
IMPOSSIBLE: See LambdaBindingBind -> HiddenBindAtBind. pLambdaBinding3 always wins over pLambdaBindingBind due to parser ordering and partial consumption.

PAIR: LambdaBindingBind -> HiddenBindLiteralValue
IMPOSSIBLE: See LambdaBindingBind -> HiddenBindAtBind. pLambdaBinding3 always wins over pLambdaBindingBind due to parser ordering and partial consumption.

PAIR: LambdaBindings -> LambdaBindingBind
IMPOSSIBLE: See LambdaBindingBind -> HiddenBindAtBind. pLambdaBinding3 always wins over pLambdaBindingBind due to parser ordering and partial consumption.

PAIR: LambdaExpression -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: LambdaExpression -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: LetStatement -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: LetStatement -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: LoopExpression -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: LoopExpression -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: MatchArm -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: MatchArm -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: MatchCondition -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: MatchCondition -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: MatchExpression -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: MatchExpression -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: MoveOrCopyExpression -> HiddenExpressionBinaryExpression
IMPOSSIBLE: move_or_copy_expression has prec(13), which is higher than all binary operators (prec 2-12). In `move x + y`, the precedence conflict is resolved in favor of move binding `x` tightly: `(move x) + y`. There is no way for a binary expression to be the direct child of move/copy because move/copy always claims the immediate operand before any binary operator can form a binary expression around it.

PAIR: MoveOrCopyExpression -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: MoveOrCopyExpression -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: QuantifierBinding2 -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: QuantifierBinding2 -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: QuantifierExpression -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: QuantifierExpression -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: ReturnExpression1 -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: ReturnExpression1 -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: SpecApply -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: SpecApply -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: SpecInclude -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: SpecInclude -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: SpecInvariant -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: SpecInvariant -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: SpecLet -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: SpecLet -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: UnaryExpression -> HiddenExpressionAssignExpression
IMPOSSIBLE: The `unary_expression` takes `_expression` as its child, and `assign_expression` has prec.left(1). When parsing `!x = 5`, there is a shift-reduce conflict at `=`: the parser can either reduce `!x` as a complete `unary_expression` (prec 10 via `_unary_expression`) or shift `=` to continue building `assign_expression(x, =, 5)` inside the unary (prec 1). Since 10 > 1, the reduce wins, giving `assign_expression(unary_expression(!, x), =, 5)`. There is no way to get an `assign_expression` as the direct `_expression` child of `unary_expression` because the unary operator always binds more tightly than assignment. Parentheses would create an `expression_list` node, not an `assign_expression`.

PAIR: UnaryExpression -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: UnaryExpression -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: VectorExpression -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: VectorExpression -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: WhileExpression -> HiddenExpressionMatchExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

PAIR: WhileExpression -> HiddenExpressionVectorExpression
IMPOSSIBLE: The grammar uses [$._expression, $._expression_term] conflict for these node types. Due to tree-sitter's conflict resolution, match_expression and vector_expression are always routed through HiddenExpressionTermMatchExpression/HiddenExpressionTermVectorExpression (via the _expression_term path), never directly as HiddenExpressionMatchExpression/HiddenExpressionVectorExpression. The _expression_term choice always wins over _expression for match and vector.

